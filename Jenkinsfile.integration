#!groovy

// Global vars so they can be used in different steps
DocsChanged = false
PlaybooksChanged = false
ToxChanged = false
DocsOnlyRun = false


pipeline {

    options {
        timestamps()
        parallelsAlwaysFailFast()
        // Note(jhesketh): Unfortunately we can't set a global timeout for the
        //                 pipeline as it would also apply to the post stages
        //                 and hence interrupt our cleanup.
    }

    agent {
        node {
            label "cloud-ccp-ci"
        }
    }

    parameters {
        /* first value in the list is the default */
        choice(choices: ['airship', 'osh'], description: 'Which deployment mechanism?', name: 'deployment')
    }

    environment {
        /* Sanitize ENVNAME (lowercase and remove some problematic characters)
           as the names of the heat stacks will be derived from this. Also
           the CaaSP Velum automation has issues with mixed case hostnames. */
        SOCOK8S_ENVNAME = "cloud-socok8s-${env.BRANCH_NAME.replaceAll("[^a-zA-Z0-9-]+", "-").toLowerCase()}-${env.BUILD_NUMBER}"
        OS_CLOUD = "engcloud-cloud-ci"
        KEYNAME = "engcloud-cloud-ci"
        DELETE_ANYWAY = "YES"
        SOCOK8S_DEVELOPER_MODE = "True"
        DEPLOYMENT_MECHANISM = "openstack"
        ANSIBLE_STDOUT_CALLBACK = "yaml"
        USER = "jenkins" /* Why isn't this set in the jenkins environment? */
    }

    stages {
        stage('Show environment information') {
            steps {
                sh 'printenv'
            }
        }
        stage('Check for updated files') {
            when { expression { env.BRANCH_NAME != 'master' } }
            steps {
                script {
                    /* Need to fetch master to check against it for the proper diff */
                    sh "git config --add remote.origin.fetch +refs/heads/master:refs/remotes/origin/master"
                    sh "git fetch --no-tags"
                    List<String> sourceChanged = sh(returnStdout: true, script: "git diff --name-only origin/master..origin/${env.BRANCH_NAME}").split()
                    echo "Files changed for this PR:\n${sourceChanged.join('\n')}"
                    DocsChanged = sourceChanged.any{it.contains("doc/")}
                    PlaybooksChanged = sourceChanged.any{it.contains("playbooks/")}
                    ToxChanged = sourceChanged.any{it.contains("tox.ini")}
                    // if only changed files are docs files, run only the docs building
                    DocsOnlyRun = sourceChanged.every{it.contains("doc/")}
                }
            }
        }

        stage('Lint Ansible playbooks') {
            // run only if playbooks have changed and this is not a docs only run
            when {
                allOf {
                    expression { return PlaybooksChanged }
                    expression { return !DocsOnlyRun }
                }
            }

            options {
                timeout(time: 5, unit: 'MINUTES', activity: true)
            }
            steps {
                sh "tox -e lint"
            }
        }

        stage('Build docs') {
             when {
                anyOf {
                    expression { return DocsChanged }
                    expression { return ToxChanged }
                }
             }
             options {
                timeout(time: 5, unit: 'MINUTES', activity: true)
             }
             steps {
                sh "tox -e docs"
             }
             post {
                success {
                    publishHTML target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: false,
                        keepAll: true,
                        reportDir: 'doc/build/html',
                        reportFiles: 'index.html',
                        reportName: 'Built Docs'
                    ]
                }
             }
        }

        stage('Create network') {
            // do not run if its a docs only run (only doc files changed)
            when { expression { return !DocsOnlyRun } }
            options {
                timeout(time: 10, unit: 'MINUTES', activity: true)
            }
            steps {
                sh "./run.sh deploy_network"
            }
        }
        stage('Create VMs') {
            // do not run if its a docs only run (only doc files changed)
            when { expression { return !DocsOnlyRun } }
            options {
                timeout(time: 45, unit: 'MINUTES', activity: true)
            }
            parallel {
                stage('Deploy CaaSP') {
                    steps {
                        sh "./run.sh deploy_caasp"
                    }
                }
                stage('Deploy SES') {
                    steps {
                        sh "./run.sh deploy_ses"
                    }
                }
                stage('Deploy CCP Deployer') {
                    steps {
                        sh "./run.sh deploy_ccp_deployer"
                    }
                }
            }
        }

        stage('Configure CaaSP workers') {
            // do not run if its a docs only run (only doc files changed)
            when { expression { return !DocsOnlyRun } }
            options {
                timeout(time: 10, unit: 'MINUTES', activity: true)
            }
            steps {
                sh "./run.sh enroll_caasp_workers"
                sh "./run.sh setup_caasp_workers_for_openstack"
            }
        }

        stage('Deploy OpenStack Helm') {
            // do not run ff its a docs only run (only doc files changed)
            when {
                allOf {
                    expression { params.deployment == "osh" }
                    expression { return !DocsOnlyRun }
                }
            }
            options {
                timeout(time: 20, unit: 'MINUTES', activity: true)
            }
            steps {
                sh "./run.sh patch_upstream"
                sh "./run.sh build_images"
                sh "./run.sh deploy_osh"
            }
        }

        stage('Deploy Airship') {
            // do not run if its a docs only run (only doc files changed)
            when {
                allOf {
                    expression { params.deployment == "airship" }
                    expression { return !DocsOnlyRun }
                }
            }
            options {
                timeout(time: 45, unit: 'MINUTES', activity: true)
            }
            steps {
                sh "./run.sh setup_airship"
            }
        }
    }

    post {
        failure {
            script {
                if (env.hold_instance_for_debug == 'true') {
                    echo "You can reach this node by connecting to its floating IP as root user, with the default password of your image."
                    timeout(time: 3, unit: 'HOURS') {
                        input(message: "Waiting for input before deleting  env ${SOCOK8S_ENVNAME}.")
                    }
                }
            }
            script {
                sh './run.sh gather_logs'
            }
            zip archive: true, dir: 'logs/', zipFile: 'logs.zip'
            archiveArtifacts artifacts: 'logs.zip'
        }
        cleanup {
            script {
                    sh './run.sh teardown'
                }
        }
    }
}
